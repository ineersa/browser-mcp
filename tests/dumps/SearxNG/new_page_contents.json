{
  "new_page": {
    "url": "https://symfony.com/doc/current/scheduler.html",
    "text": "\nURL: https://symfony.com/doc/current/scheduler.html\nSkip to content \n\n\u30100\u2020 \u3011 \n\nClose\n\n  * About\n\n    * \u30101\u2020What is Symfony?\u3011 \n    * \u30102\u2020Community\u3011 \n    * \u30103\u2020News\u3011 \n    * \u30104\u2020Contributing\u3011 \n    * \u30105\u2020Support\u3011 \n\n  * Documentation\n\n    * \u30106\u2020Symfony Docs\u3011 \n    * \u30107\u2020Symfony Book\u3011 \n    * \u30108\u2020Screencasts\u2020symfonycasts.com\u3011 \n    * \u30109\u2020Symfony Bundles\u3011 \n    * \u301010\u2020Symfony Cloud\u3011 \n    * \u301011\u2020Training\u2020sensiolabs.com\u3011 \n\n  * Services\n\n    * \u301012\u2020Platform.sh for Symfony\u3011 Best platform to deploy Symfony apps\n    * \u301013\u2020SymfonyInsight\u2020insight.symfony.com\u3011 Automatic quality checks for your apps\n    * \u301014\u2020Symfony Certification\u2020certification.symfony.com\u3011 Prove your knowledge and boost your career\n    * \u301015\u2020SensioLabs\u2020sensiolabs.com\u3011 Professional services to help you with Symfony\n    * \u301016\u2020Blackfire\u2020www.blackfire.io\u3011 Profile and monitor performance of your apps\n\n  * Other\n  * \u30103\u2020Blog\u3011 \n  * \u301017\u2020Download\u3011 \n\nsponsored by \u301018\u2020 .logo-sensiolabs path.sensio-word { fill: #000000; } .logo-sensiolabs path.labs-word { fill: #82E83F; } .dark-theme .logo-sensiolabs path.sensio-word { fill: #FFFFFF; } .logo-sensiolabs path.sensio-word { fill: #000000; } .logo-sensiolabs path.labs-word { fill: #82E83F; } .dark-theme .logo-sensiolabs path.sensio-word { fill: #FFFFFF; } \u2020sensiolabs.com\u3011 \n\n  1. \u30100\u2020Home\u3011 \n  2. \u30106\u2020Documentation\u3011 \n  3. Scheduler \n\nSearch Symfony Docs \n\nVersion: 8.0  7.4 (dev)  7.3 (current)  6.4  7.2  7.1  7.0  6.3  6.2  6.1  6.0  5.x  4.x  3.x  2.x \n\nTable of Contents\n\n  * Installation \n  * Symfony Scheduler Basics \n  * Attaching Recurring Messages to a Schedule \n  * Scheduling Recurring Messages \n    * Cron Expression Triggers \n    * Periodical Triggers \n    * Custom Triggers \n    * A Dynamic Vision for the Messages Generated \n    * Exploring Alternatives for Crafting your Recurring Messages \n  * Managing Scheduled Messages \n    * Modifying Scheduled Messages in Real-Time \n    * Strategies for Adding, Removing, and Modifying Entries within the Schedule \n  * Managing Scheduled Messages via Events \n    * A Strategic Event Handling \n    * Scheduler Events \n  * Consuming Messages \n    * Running a Worker \n    * Creating a Consumer Programmatically \n  * Modifying the Schedule at Runtime \n  * Debugging the Schedule \n  * Efficient management with Symfony Scheduler \n\n#  Scheduler \n\n\u301019\u2020 Edit this page \u2020github.com\u3011 \n\nScreencast\n\nLike video tutorials? Check out this \u301020\u2020Scheduler quick-start screencast\u2020symfonycasts.com\u3011.\n\nThe scheduler component manages task scheduling within your PHP application, like running a task each night at 3 AM, every two weeks except for holidays or any other custom schedule you might need.\n\nThis component is useful to schedule tasks like maintenance (database cleanup, cache clearing, etc.), background processing (queue handling, data synchronization, etc.), periodic data updates, scheduled notifications (emails, alerts), and more.\n\nThis document focuses on using the Scheduler component in the context of a full stack Symfony application.\n\n## Installation\n\nRun this command to install the scheduler component:\n\n    1\n\n    $ composer require symfony/scheduler\n\nNote\n\nIn applications using \u301021\u2020Symfony Flex\u3011, installing the component also creates an initial schedule that's ready to start adding your tasks.\n\n## Symfony Scheduler Basics\n\nThe main benefit of using this component is that automation is managed by your application, which gives you a lot of flexibility that is not possible with cron jobs (e.g. dynamic schedules based on certain conditions).\n\nAt its core, the Scheduler component allows you to create a task (called a message) that is executed by a service and repeated on some schedule. It has some similarities with the \u301022\u2020Symfony Messenger\u3011 component (such as message, handler, bus, transport, etc.), but the main difference is that Messenger can't deal with repetitive tasks at regular intervals.\n\nConsider the following example of an application that sends some reports to customers on a scheduled basis. First, create a Scheduler message that represents the task of creating a report:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n\n    // src/Scheduler/Message/SendDailySalesReports.php\n    namespace App\\Scheduler\\Message;\n\n    class SendDailySalesReports\n    {\n        public function __construct(private int $id) {}\n\n        public function getId(): int\n        {\n            return $this->id;\n        }\n    }\n\nNext, create the handler that processes that kind of message:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n\n    // src/Scheduler/Handler/SendDailySalesReportsHandler.php\n    namespace App\\Scheduler\\Handler;\n\n    use App\\Scheduler\\Message\\SendDailySalesReports;\n    use Symfony\\Component\\Messenger\\Attribute\\AsMessageHandler;\n\n    #[AsMessageHandler]\n    class SendDailySalesReportsHandler\n    {\n        public function __invoke(SendDailySalesReports $message)\n        {\n            // ... do some work to send the report to the customers\n        }\n    }\n\nInstead of sending these messages immediately (as in the Messenger component), the goal is to create them based on a predefined frequency. This is possible thanks to \u301023\u2020SchedulerTransport\u2020github.com\u3011, a special transport for Scheduler messages.\n\nThe transport generates, autonomously, various messages according to the assigned frequencies. The following images illustrate the differences between the processing of messages in Messenger and Scheduler components:\n\nIn Messenger:\n\n[Image 0: Symfony Messenger basic cycle] \n\nIn Scheduler:\n\n[Image 1: Symfony Scheduler basic cycle] \n\nAnother important difference is that messages in the Scheduler component are recurring. They are represented via the \u301024\u2020RecurringMessage\u2020github.com\u3011 class.\n\n## Attaching Recurring Messages to a Schedule\n\nThe configuration of the message frequency is stored in a class that implements \u301025\u2020ScheduleProviderInterface\u2020github.com\u3011. This provider uses the method \u301026\u2020getSchedule()\u2020github.com\u3011 to return a schedule containing the different recurring messages.\n\nThe \u301027\u2020AsSchedule\u2020github.com\u3011 attribute, which by default references the schedule named `default`, allows you to register on a particular schedule:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsSchedule;\n    use Symfony\\Component\\Scheduler\\Schedule;\n    use Symfony\\Component\\Scheduler\\ScheduleProviderInterface;\n\n    #[AsSchedule]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            // ...\n        }\n    }\n\nTip\n\nBy default, the schedule name is `default` and the transport name follows the syntax: `scheduler_nameofyourschedule` (e.g. `scheduler_default`).\n\nTip\n\n\u301028\u2020Memoizing\u2020en.wikipedia.org\u3011 your schedule is a good practice to prevent unnecessary reconstruction if the `getSchedule()` method is checked by another service.\n\n## Scheduling Recurring Messages\n\nA `RecurringMessage` is a message associated with a trigger, which configures the frequency of the message. Symfony provides different types of triggers:\n\n\u301029\u2020CronExpressionTrigger\u2020github.com\u3011\n     A trigger that uses the same syntax as the \u301030\u2020cron command-line utility\u2020en.wikipedia.org\u3011. \n\u301031\u2020CallbackTrigger\u2020github.com\u3011\n     A trigger that uses a callback to determine the next run date. \n\u301032\u2020ExcludeTimeTrigger\u2020github.com\u3011\n     A trigger that excludes certain times from a given trigger. \n\u301033\u2020JitterTrigger\u2020github.com\u3011\n     A trigger that adds a random jitter to a given trigger. The jitter is some time that is added to the original triggering date/time. This allows to distribute the load of the scheduled tasks instead of running them all at the exact same time. \n\u301034\u2020PeriodicalTrigger\u2020github.com\u3011\n     A trigger that uses a `DateInterval` to determine the next run date. \n\nThe \u301033\u2020JitterTrigger\u2020github.com\u3011 and \u301032\u2020ExcludeTimeTrigger\u2020github.com\u3011 are decorators and modify the behavior of the trigger they wrap. You can get the decorated trigger as well as the decorators by calling the \u301035\u2020inner()\u2020github.com\u3011 and \u301036\u2020decorators()\u2020github.com\u3011 methods:\n\n    1\n    2\n    3\n    4\n\n    $trigger = new ExcludeTimeTrigger(new JitterTrigger(CronExpressionTrigger::fromSpec('#midnight', new MyMessage()));\n\n    $trigger->inner(); // CronExpressionTrigger\n    $trigger->decorators(); // [ExcludeTimeTrigger, JitterTrigger]\n\nMost of them can be created via the \u301024\u2020RecurringMessage\u2020github.com\u3011 class, as shown in the following examples.\n\n### Cron Expression Triggers\n\nBefore using cron triggers, you have to install the following dependency:\n\n    1\n\n    $ composer require dragonmantank/cron-expression\n\nThen, define the trigger date/time using the same syntax as the \u301030\u2020cron command-line utility\u2020en.wikipedia.org\u3011:\n\n    1\n    2\n    3\n    4\n\n    RecurringMessage::cron('* * * * *', new Message());\n\n    // optionally you can define the timezone used by the cron expression\n    RecurringMessage::cron('* * * * *', new Message(), new \\DateTimeZone('Africa/Malabo'));\n\nTip\n\nCheck out the \u301037\u2020crontab.guru website\u2020crontab.guru\u3011 if you need help to construct/understand cron expressions.\n\nYou can also use some special values that represent common cron expressions:\n\n  * `@yearly`, `@annually` \\- Run once a year, midnight, Jan. 1 - `0 0 1 1 *`\n  * `@monthly` \\- Run once a month, midnight, first of month - `0 0 1 * *`\n  * `@weekly` \\- Run once a week, midnight on Sun - `0 0 * * 0`\n  * `@daily`, `@midnight` \\- Run once a day, midnight - `0 0 * * *`\n  * `@hourly` \\- Run once an hour, first minute - `0 * * * *`\n\nFor example:\n\n    1\n\n    RecurringMessage::cron('@daily', new Message());\n\nTip\n\nYou can also define cron tasks using \u301038\u2020the AsCronTask attribute\u3011.\n\n#### Hashed Cron Expressions\n\nIf you have many triggers scheduled at same time (for example, at midnight, `0 0 * * *`) this will create a very long running list of schedules at that exact time. This may cause an issue if a task has a memory leak.\n\nYou can add a hash symbol (`#`) in expressions to generate random values. Although the values are random, they are predictable and consistent because they are generated based on the message. A message with string representation `my task` and a defined frequency of `# # * * *` will have an idempotent frequency of `56 20 * * *` (every day at 8:56pm).\n\nYou can also use hash ranges (`#(x-y)`) to define the list of possible values for that random part. For example, `# #(0-7) * * *` means daily, some time between midnight and 7am. Using the `#` without a range creates a range of any valid value for the field. `# # # # #` is short for `#(0-59) #(0-23) #(1-28) #(1-12) #(0-6)`.\n\nYou can also use some special values that represent common hashed cron expressions:\n\nAlias Converts to  \n`#hourly` `# * * * *` (at some minute every hour)  \n`#daily` `# # * * *` (at some time every day)  \n`#weekly` `# # * * #` (at some time every week)  \n`#weekly@midnight` `# #(0-2) * * #` (at `#midnight` one day every week)  \n`#monthly` `# # # * *` (at some time on some day, once per month)  \n`#monthly@midnight` `# #(0-2) # * *` (at `#midnight` on some day, once per month)  \n`#annually` `# # # # *` (at some time on some day, once per year)  \n`#annually@midnight` `# #(0-2) # # *` (at `#midnight` on some day, once per year)  \n`#yearly` `# # # # *` alias for `#annually`  \n`#yearly@midnight` `# #(0-2) # # *` alias for `#annually@midnight`  \n`#midnight` `# #(0-2) * * *` (at some time between midnight and 2:59am, every day)  \n\nFor example:\n\n    1\n\n    RecurringMessage::cron('#midnight', new Message());\n\nNote\n\nThe day of month range is `1-28`, this is to account for February which has a minimum of 28 days.\n\n### Periodical Triggers\n\nThese triggers allows to configure the frequency using different data types (`string`, `integer`, `DateInterval`). They also support the \u301039\u2020relative formats\u2020www.php.net\u3011 defined by PHP datetime functions:\n\n    1\n    2\n    3\n\n    RecurringMessage::every('10 seconds', new Message());\n    RecurringMessage::every('3 weeks', new Message());\n    RecurringMessage::every('first Monday of next month', new Message());\n\nNote\n\nComma-separated weekdays (e.g., `'Monday, Thursday, Saturday'`) are not supported by the `every()` method. For multiple weekdays, use cron expressions instead:\n\n    1\n    2\n\n    - RecurringMessage::every('Monday, Thursday, Saturday', new Message());\n    + RecurringMessage::cron('5 12 * * 1,4,6', new Message());\n\nTip\n\nYou can also define periodic tasks using \u301040\u2020the AsPeriodicTask attribute\u3011.\n\nYou can also define `from` and `until` times for your schedule:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n\n    // create a message every day at 13:00\n    $from = new \\DateTimeImmutable('13:00', new \\DateTimeZone('Europe/Paris'));\n    RecurringMessage::every('1 day', new Message(), $from);\n\n    // create a message every day until a specific date\n    $until = '2023-06-12';\n    RecurringMessage::every('1 day', new Message(), null, $until);\n\n    // combine from and until for more precise control\n    $from = new \\DateTimeImmutable('2023-01-01 13:47', new \\DateTimeZone('Europe/Paris'));\n    $until = '2023-06-12';\n    RecurringMessage::every('first Monday of next month', new Message(), $from, $until);\n\nWhen starting the scheduler, the message isn't sent to the messenger immediately. If you don't set a `from` parameter, the first frequency period starts from the moment the scheduler runs. For example, if you start it at 8:33 and the message is scheduled hourly, it will run at 9:33, 10:33, 11:33, etc.\n\n### Custom Triggers\n\nCustom triggers allow to configure any frequency dynamically. They are created as services that implement \u301041\u2020TriggerInterface\u2020github.com\u3011.\n\nFor example, if you want to send customer reports daily except for holiday periods:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n\n    // src/Scheduler/Trigger/NewUserWelcomeEmailHandler.php\n    namespace App\\Scheduler\\Trigger;\n\n    class ExcludeHolidaysTrigger implements TriggerInterface\n    {\n        public function __construct(private TriggerInterface $inner)\n        {\n        }\n\n        // use this method to give a nice displayable name to\n        // identify your trigger (it eases debugging)\n        public function __toString(): string\n        {\n            return $this->inner.' (except holidays)';\n        }\n\n        public function getNextRunDate(\\DateTimeImmutable $run): ?\\DateTimeImmutable\n        {\n            if (!$nextRun = $this->inner->getNextRunDate($run)) {\n                return null;\n            }\n\n            // loop until you get the next run date that is not a holiday\n            while ($this->isHoliday($nextRun)) {\n                $nextRun = $this->inner->getNextRunDate($nextRun);\n            }\n\n            return $nextRun;\n        }\n\n        private function isHoliday(\\DateTimeImmutable $timestamp): bool\n        {\n            // add some logic to determine if the given $timestamp is a holiday\n            // return true if holiday, false otherwise\n        }\n    }\n\nThen, define your recurring message:\n\n    1\n    2\n    3\n    4\n    5\n    6\n\n    RecurringMessage::trigger(\n        new ExcludeHolidaysTrigger(\n            CronExpressionTrigger::fromSpec('@daily'),\n        ),\n        new SendDailySalesReports('...'),\n    );\n\nFinally, the recurring messages has to be attached to a schedule:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::trigger(\n                        new ExcludeHolidaysTrigger(\n                            CronExpressionTrigger::fromSpec('@daily'),\n                        ),\n                        new SendDailySalesReports()\n                    ),\n                    RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport())\n                );\n        }\n    }\n\nSo, this `RecurringMessage` will encompass both the trigger, defining the generation frequency of the message, and the message itself, the one to be processed by a specific handler.\n\nBut what is interesting to know is that it also provides you with the ability to generate your message(s) dynamically.\n\n### A Dynamic Vision for the Messages Generated\n\nThis proves particularly useful when the message depends on data stored in databases or third-party services.\n\nFollowing the previous example of reports generation: they depend on customer requests. Depending on the specific demands, any number of reports may need to be generated at a defined frequency. For these dynamic scenarios, it gives you the capability to dynamically define our message(s) instead of statically. This is achieved by defining a \u301042\u2020CallbackMessageProvider\u2020github.com\u3011.\n\nEssentially, this means you can dynamically, at runtime, define your message(s) through a callback that gets executed each time the scheduler transport checks for messages to be generated:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::trigger(\n                        new ExcludeHolidaysTrigger(\n                            CronExpressionTrigger::fromSpec('@daily'),\n                        ),\n                        // instead of being static as in the previous example\n                        new CallbackMessageProvider([$this, 'generateReports'], 'foo')\n                    ),\n                    RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport())\n                );\n        }\n\n        public function generateReports(MessageContext $context)\n        {\n            // ...\n            yield new SendDailySalesReports();\n            yield new ReportSomethingReportSomethingElse();\n        }\n    }\n\n### Exploring Alternatives for Crafting your Recurring Messages\n\nThere is also another way to build a `RecurringMessage`, and this can be done by adding one of these attributes to a service or a command: \u301043\u2020AsPeriodicTask\u2020github.com\u3011 and \u301044\u2020AsCronTask\u2020github.com\u3011.\n\nFor both of these attributes, you have the ability to define the schedule to use via the `schedule` option. By default, the `default` named schedule will be used. Also, by default, the `__invoke` method of your service will be called but, it's also possible to specify the method to call via the `method` option and you can define arguments via `arguments` option if necessary.\n\n#### AsCronTask Example\n\nThis is the most basic way to define a cron trigger with this attribute:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n\n    // src/Scheduler/Task/SendDailySalesReports.php\n    namespace App\\Scheduler\\Task;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsCronTask;\n\n    #[AsCronTask('0 0 * * *')]\n    class SendDailySalesReports\n    {\n        public function __invoke()\n        {\n            // ...\n        }\n    }\n\nThe attribute takes more parameters to customize the trigger:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n\n    // adds randomly up to 6 seconds to the trigger time to avoid load spikes\n    #[AsCronTask('0 0 * * *', jitter: 6)]\n\n    // defines the method name to call instead as well as the arguments to pass to it\n    #[AsCronTask('0 0 * * *', method: 'sendEmail', arguments: ['email' => 'admin@example.com'])]\n\n    // defines the timezone to use\n    #[AsCronTask('0 0 * * *', timezone: 'Africa/Malabo')]\n\n    // when applying this attribute to a Symfony console command, you can pass\n    // arguments and options to the command using the 'arguments' option:\n    #[AsCronTask('0 0 * * *', arguments: 'some_argument --some-option --another-option=some_value')]\n    #[AsCommand(name: 'app:my-command')]\n    class MyCommand\n\n#### AsPeriodicTask Example\n\nThis is the most basic way to define a periodic trigger with this attribute:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n\n    // src/Scheduler/Task/SendDailySalesReports.php\n    namespace App\\Scheduler\\Task;\n\n    use Symfony\\Component\\Scheduler\\Attribute\\AsPeriodicTask;\n\n    #[AsPeriodicTask(frequency: '1 day', from: '2022-01-01', until: '2023-06-12')]\n    class SendDailySalesReports\n    {\n        public function __invoke()\n        {\n            // ...\n        }\n    }\n\nNote\n\nThe `from` and `until` options are optional. If not defined, the task will be executed indefinitely.\n\nThe `#[AsPeriodicTask]` attribute takes many parameters to customize the trigger:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n\n    // the frequency can be defined as an integer representing the number of seconds\n    #[AsPeriodicTask(frequency: 86400)]\n\n    // adds randomly up to 6 seconds to the trigger time to avoid load spikes\n    #[AsPeriodicTask(frequency: '1 day', jitter: 6)]\n\n    // defines the method name to call instead as well as the arguments to pass to it\n    #[AsPeriodicTask(frequency: '1 day', method: 'sendEmail', arguments: ['email' => 'admin@symfony.com'])]\n    class SendDailySalesReports\n    {\n        public function sendEmail(string $email): void\n        {\n            // ...\n        }\n    }\n\n    // when applying this attribute to a Symfony console command, you can pass\n    // arguments and options to the command using the 'arguments' option:\n    #[AsPeriodicTask(frequency: '1 day', arguments: 'some_argument --some-option --another-option=some_value')]\n    #[AsCommand(name: 'app:my-command')]\n    class MyCommand\n\n## Managing Scheduled Messages\n\n### Modifying Scheduled Messages in Real-Time\n\nWhile planning a schedule in advance is beneficial, it is rare for a schedule to remain static over time. After a certain period, some `RecurringMessages` may become obsolete, while others may need to be integrated into the planning.\n\nAs a general practice, to alleviate a heavy workload, the recurring messages in the schedules are stored in memory to avoid recalculation each time the scheduler transport generates messages. However, this approach can have a flip side.\n\nFollowing the same report generation example as above, the company might do some promotions during specific periods (and they need to be communicated repetitively throughout a given timeframe) or the deletion of old reports needs to be halted under certain circumstances.\n\nThis is why the `Scheduler` incorporates a mechanism to dynamically modify the schedule and consider all changes in real-time.\n\n### Strategies for Adding, Removing, and Modifying Entries within the Schedule\n\nThe schedule provides you with the ability to \u301045\u2020add()\u2020github.com\u3011, \u301046\u2020remove()\u2020github.com\u3011, or \u301047\u2020clear()\u2020github.com\u3011 all associated recurring messages, resulting in the reset and recalculation of the in-memory stack of recurring messages.\n\nFor instance, for various reasons, if there's no need to generate a report, a callback can be employed to conditionally skip generating of some or all reports.\n\nHowever, if the intention is to completely remove a recurring message and its recurrence, the \u301048\u2020Schedule\u2020github.com\u3011 offers a \u301046\u2020remove()\u2020github.com\u3011 or a \u301049\u2020removeById()\u2020github.com\u3011 method. This can be particularly useful in your case, especially if you need to halt the generation of the recurring message, which involves deleting old reports.\n\nIn your handler, you can check a condition and, if affirmative, access the \u301048\u2020Schedule\u2020github.com\u3011 and invoke this method:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                    $this->removeOldReports;\n                );\n        }\n\n        // ...\n\n        public function removeCleanUpMessage()\n        {\n            $this->getSchedule()->getSchedule()->remove($this->removeOldReports);\n        }\n    }\n\n    // src/Scheduler/Handler/CleanUpOldSalesReportHandler.php\n    namespace App\\Scheduler\\Handler;\n\n    #[AsMessageHandler]\n    class CleanUpOldSalesReportHandler\n    {\n        public function __invoke(CleanUpOldSalesReport $cleanUpOldSalesReport): void\n        {\n            // do some work here...\n\n            if ($isFinished) {\n                $this->mySchedule->removeCleanUpMessage();\n            }\n        }\n    }\n\nNevertheless, this system may not be the most suitable for all scenarios. Also, the handler should ideally be designed to process the type of message it is intended for, without making decisions about adding or removing a new recurring message.\n\nFor instance, if, due to an external event, there is a need to add a recurrent message aimed at deleting reports, it can be challenging to achieve within the handler. This is because the handler will no longer be called or executed once there are no more messages of that type.\n\nHowever, the Scheduler also features an event system that is integrated into a Symfony full-stack application by grafting onto Symfony Messenger events. These events are dispatched through a listener, providing a convenient means to respond.\n\n## Managing Scheduled Messages via Events\n\n### A Strategic Event Handling\n\nThe goal is to provide flexibility in deciding when to take action while preserving decoupling. Three primary event types have been introduced types\n\n  * `PRE_RUN_EVENT`\n  * `POST_RUN_EVENT`\n  * `FAILURE_EVENT`\n\nAccess to the schedule is a crucial feature, allowing effortless addition or removal of message types. Additionally, it will be possible to access the currently processed message and its message context.\n\nIn consideration of our scenario, you can listen to the `PRE_RUN_EVENT` and check if a certain condition is met. For instance, you might decide to add a recurring message for cleaning old reports again, with the same or different configurations, or add any other recurring message(s).\n\nIf you had chosen to handle the deletion of the recurring message, you could have done so in a listener for this event. Importantly, it reveals a specific feature \u301050\u2020shouldCancel()\u2020github.com\u3011 that allows you to prevent the message of the deleted recurring message from being transferred and processed by its handler:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function __construct(private EventDispatcherInterface $dispatcher)\n        {\n        }\n\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule($this->dispatcher))\n                ->with(\n                    // ...\n                )\n                ->before(function(PreRunEvent $event) {\n                    $message = $event->getMessage();\n                    $messageContext = $event->getMessageContext();\n\n                    // can access the schedule\n                    $schedule = $event->getSchedule()->getSchedule();\n\n                    // can target directly the RecurringMessage being processed\n                    $schedule->removeById($messageContext->id);\n\n                    // allow to call the ShouldCancel() and avoid the message to be handled\n                    $event->shouldCancel(true);\n                })\n                ->after(function(PostRunEvent $event) {\n                    // Do what you want\n                })\n                ->onFailure(function(FailureEvent $event) {\n                    // Do what you want\n                });\n        }\n    }\n\n### Scheduler Events\n\n#### PreRunEvent\n\nEvent Class: \u301051\u2020PreRunEvent\u2020github.com\u3011\n\n`PreRunEvent` allows to modify the \u301048\u2020Schedule\u2020github.com\u3011 or cancel a message before it's consumed:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\PreRunEvent;\n\n    public function onMessage(PreRunEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n\n        // do something with the schedule, context or message\n\n        // and/or cancel message\n        $event->shouldCancel(true);\n    }\n\nExecute this command to find out which listeners are registered for this event and their priorities:\n\n    1\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\PreRunEvent\"\n\n#### PostRunEvent\n\nEvent Class: \u301052\u2020PostRunEvent\u2020github.com\u3011\n\n`PostRunEvent` allows to modify the \u301048\u2020Schedule\u2020github.com\u3011 after a message is consumed:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\PostRunEvent;\n\n    public function onMessage(PostRunEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n        $result = $event->getResult();\n\n        // do something with the schedule, context, message or result\n    }\n\n7.3\n\nThe `getResult()` method was introduced in Symfony 7.3.\n\nExecute this command to find out which listeners are registered for this event and their priorities:\n\n    1\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\PostRunEvent\"\n\n#### FailureEvent\n\nEvent Class: \u301053\u2020FailureEvent\u2020github.com\u3011\n\n`FailureEvent` allows to modify the \u301048\u2020Schedule\u2020github.com\u3011 when a message consumption throws an exception:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n\n    use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n    use Symfony\\Component\\Scheduler\\Event\\FailureEvent;\n\n    public function onMessage(FailureEvent $event): void\n    {\n        $schedule = $event->getSchedule();\n        $context = $event->getMessageContext();\n        $message = $event->getMessage();\n\n        $error = $event->getError();\n\n        // do something with the schedule, context, message or error (logging, ...)\n\n        // and/or ignore failure event\n        $event->shouldIgnore(true);\n    }\n\nExecute this command to find out which listeners are registered for this event and their priorities:\n\n    1\n\n    $ php bin/console debug:event-dispatcher \"Symfony\\Component\\Scheduler\\Event\\FailureEvent\"\n\n## Consuming Messages\n\nThe Scheduler component offers two ways to consume messages, depending on your needs: using the `messenger:consume` command or creating a worker programmatically. The first solution is the recommended one when using the Scheduler component in the context of a full stack Symfony application, the second one is more suitable when using the Scheduler component as a standalone component.\n\n### Running a Worker\n\nAfter defining and attaching your recurring messages to a schedule, you'll need a mechanism to generate and consume the messages according to their defined frequencies. To do that, the Scheduler component uses the `messenger:consume` command from the Messenger component:\n\n    1\n    2\n    3\n    4\n\n    $ php bin/console messenger:consume scheduler_nameofyourschedule\n\n    # use -vv if you need details about what's happening\n    $ php bin/console messenger:consume scheduler_nameofyourschedule -vv\n\n[Image 2: Symfony Scheduler - generate and consume] \n\nTip\n\nDepending on your deployment scenario, you may prefer automating the execution of the Messenger worker process using tools like cron, Supervisor, or systemd. This ensures workers are running continuously. For more details, refer to the \u301054\u2020Deploying to Production\u3011 section of the Messenger component documentation.\n\n### Creating a Consumer Programmatically\n\nAn alternative to the previous solution is to create and call a worker that will consume the messages. The component comes with a ready-to-use worker named \u301055\u2020Scheduler\u2020github.com\u3011 that you can use in your code:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n\n    use Symfony\\Component\\Scheduler\\Scheduler;\n\n    $schedule = (new Schedule())\n        ->with(\n            RecurringMessage::trigger(\n                new ExcludeHolidaysTrigger(\n                    CronExpressionTrigger::fromSpec('@daily'),\n                ),\n                new SendDailySalesReports()\n            ),\n        );\n\n    $scheduler = new Scheduler(handlers: [\n        SendDailySalesReports::class => new SendDailySalesReportsHandler(),\n        // add more handlers if you have more message types\n    ], schedules: [\n        $schedule,\n        // the scheduler can take as many schedules as you need\n    ]);\n\n    // finally, run the scheduler once it's ready\n    $scheduler->run();\n\nNote\n\nThe \u301055\u2020Scheduler\u2020github.com\u3011 may be used when using the Scheduler component as a standalone component. If you are using it in the framework context, it is highly recommended to use the `messenger:consume` command as explained in the previous section.\n\n## Modifying the Schedule at Runtime\n\nWhen a recurring message is added to or removed from the schedule, the scheduler automatically restarts and recalculates the internal trigger heap. This enables dynamic control of scheduled tasks at runtime:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n\n    // src/Scheduler/DynamicScheduleProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class DynamicScheduleProvider implements ScheduleProviderInterface\n    {\n        private ?Schedule $schedule = null;\n\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n            ;\n        }\n\n        public function clearAndAddMessages(): void\n        {\n            // clear the current schedule and add new recurring messages\n            $this->schedule?->clear();\n            $this->schedule?->add(\n                RecurringMessage::cron('@hourly', new DoActionMessage()),\n                RecurringMessage::cron('@daily', new DoAnotherActionMessage()),\n            );\n        }\n    }\n\n## Debugging the Schedule\n\nThe `debug:scheduler` command provides a list of schedules along with their recurring messages. You can narrow down the list to a specific schedule:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n\n    $ php bin/console debug:scheduler\n\n      Scheduler\n      =========\n\n      default\n      -------\n\n        ------------------- ------------------------- ----------------------\n        Trigger             Provider                  Next Run\n        ------------------- ------------------------- ----------------------\n        every 2 days        App\\Messenger\\Foo(0:17..)  Sun, 03 Dec 2023 ...\n        15 4 */3 * *        App\\Messenger\\Foo(0:17..)  Mon, 18 Dec 2023 ...\n       -------------------- -------------------------- ---------------------\n\n    # you can also specify a date to use for the next run date:\n    $ php bin/console debug:scheduler --date=2025-10-18\n\n    # you can also specify a date to use for the next run date for a schedule:\n    $ php bin/console debug:scheduler name_of_schedule --date=2025-10-18\n\n    # use the --all option to also display the terminated recurring messages\n    $ php bin/console debug:scheduler --all\n\n## Efficient management with Symfony Scheduler\n\nWhen a worker is restarted or undergoes shutdown for a period, the Scheduler transport won't be able to generate the messages (because they are created on-the-fly by the scheduler transport). This implies that any messages scheduled to be sent during the worker's inactive period are not sent, and the Scheduler will lose track of the last processed message. Upon restart, it will recalculate the messages to be generated from that point onward.\n\nTo illustrate, consider a recurring message set to be sent every 3 days. If a worker is restarted on day 2, the message will be sent 3 days from the restart, on day 5.\n\nWhile this behavior may not necessarily pose a problem, there is a possibility that it may not align with what you are seeking.\n\nThat's why the scheduler allows to remember the last execution date of a message via the `stateful` option (and the \u301056\u2020Cache component\u3011). This allows the system to retain the state of the schedule, ensuring that when a worker is restarted, it resumes from the point it left off:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n                ->stateful($this->cache)\n        }\n    }\n\nWith the `stateful` option, all missed messages will be handled. If you need to handle a message only once, you can use the `processOnlyLastMissedRun` option:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n                ->stateful($this->cache)\n                ->processOnlyLastMissedRun(true)\n        }\n    }\n\n7.2\n\nThe `processOnlyLastMissedRun` option was introduced in Symfony 7.2.\n\nTo scale your schedules more effectively, you can use multiple workers. In such cases, a good practice is to add a \u301057\u2020lock\u3011 to prevent the same task more than once:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            $this->removeOldReports = RecurringMessage::cron('3 8 * * 1', new CleanUpOldSalesReport());\n\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    // ...\n                )\n                ->lock($this->lockFactory->createLock('my-lock'));\n        }\n    }\n\nTip\n\nThe processing time of a message matters. If it takes a long time, all subsequent message processing may be delayed. So, it's a good practice to anticipate this and plan for frequencies greater than the processing time of a message.\n\nAdditionally, for better scaling of your schedules, you have the option to wrap your message in a \u301058\u2020RedispatchMessage\u2020github.com\u3011. This allows you to specify a transport on which your message will be redispatched before being further redispatched to its corresponding handler:\n\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n\n    // src/Scheduler/SaleTaskProvider.php\n    namespace App\\Scheduler;\n\n    #[AsSchedule('uptoyou')]\n    class SaleTaskProvider implements ScheduleProviderInterface\n    {\n        public function getSchedule(): Schedule\n        {\n            return $this->schedule ??= (new Schedule())\n                ->with(\n                    RecurringMessage::every('5 seconds', new RedispatchMessage(new Message(), 'async'))\n                );\n        }\n    }\n\nWhen using the `RedispatchMessage`, Symfony will attach a \u301059\u2020ScheduledStamp\u2020github.com\u3011 to the message, helping you identify those messages when needed.\n\nThis work, including the code samples, is licensed under a \u301060\u2020Creative Commons BY-SA 3.0\u2020creativecommons.org\u3011 license. \n\nTOC \n\nSearch \n\nVersion \n\nSymfony 7.3 \u301061\u2020backers\u3011 \n\n\u301062\u2020 .lestilleuls-logo-st0{fill:#EC4D28;} .dark-theme .lestilleuls-logo-wordmark-dark { fill: #fff; } \u2020les-tilleuls.coop\u3011\n\n\u301063\u2020 \u2020www.blackfire.io\u3011 \n\n\u301063\u2020Measure & Improve Symfony Code Performance\u2020www.blackfire.io\u3011 \n\n\u301064\u2020 \u2020sensiolabs.com\u3011 \n\n\u301064\u2020Peruse our complete Symfony & PHP solutions catalog for your web development needs.\u2020sensiolabs.com\u3011 \n\n## Symfony footer\n\n[Image 3: Avatar of Micha\u00ebl Mordefroy, a Symfony contributor] \n\nThanks  Micha\u00ebl Mordefroy  for being a Symfony contributor \n\n1 commit \u2022 4 lines changed\n\n\u301065\u2020View all contributors\u3011 that help us make Symfony\n\n###  Become a Symfony contributor \n\nBe an active part of the community and contribute ideas, code and bug fixes. Both experts and newcomers are welcome. \n\n\u30104\u2020Learn how to contribute\u3011 \n\nSymfony\u2122 is a trademark of Symfony SAS. \u301066\u2020All rights reserved\u3011. \n\n  * \u30101\u2020What is Symfony?\u3011\n\n    * \u30101\u2020 What is Symfony? \u3011 \n    * \u301067\u2020 Symfony at a Glance \u3011 \n    * \u301068\u2020 Symfony Packages \u3011 \n    * \u301069\u2020 Symfony Releases \u3011 \n    * \u301070\u2020 Security Policy \u3011 \n    * \u301071\u2020 Logo & Screenshots \u3011 \n    * \u301072\u2020 Trademark & Licenses \u3011 \n    * \u301073\u2020 symfony1 Legacy \u3011 \n  * \u30106\u2020Learn Symfony\u3011\n\n    * \u30106\u2020 Symfony Docs \u3011 \n    * \u30107\u2020 Symfony Book \u3011 \n    * \u301074\u2020 Reference \u3011 \n    * \u30109\u2020 Bundles \u3011 \n    * \u301075\u2020 Best Practices \u3011 \n    * \u301076\u2020 Training \u2020sensiolabs.com\u3011 \n    * \u301077\u2020 eLearning Platform \u2020university.sensiolabs.com\u3011 \n    * \u301078\u2020 Certification \u2020certification.symfony.com\u3011 \n  * \u301079\u2020Screencasts\u2020symfonycasts.com\u3011\n\n    * \u301080\u2020 Learn Symfony \u2020symfonycasts.com\u3011 \n    * \u301081\u2020 Learn PHP \u2020symfonycasts.com\u3011 \n    * \u301082\u2020 Learn JavaScript \u2020symfonycasts.com\u3011 \n    * \u301083\u2020 Learn Drupal \u2020symfonycasts.com\u3011 \n    * \u301084\u2020 Learn RESTful APIs \u2020symfonycasts.com\u3011 \n  * \u30102\u2020Community\u3011\n\n    * \u30102\u2020 Symfony Community \u3011 \n    * \u301085\u2020 SymfonyConnect \u2020connect.symfony.com\u3011 \n    * \u301086\u2020 Events & Meetups \u3011 \n    * \u301087\u2020 Projects using Symfony \u3011 \n    * \u301065\u2020 Contributors \u3011 \n    * \u301088\u2020 Symfony Jobs \u3011 \n    * \u301061\u2020 Backers \u3011 \n    * \u301089\u2020 Code of Conduct \u3011 \n    * \u301090\u2020 Downloads Stats \u3011 \n    * \u30105\u2020 Support \u3011 \n  * \u30103\u2020Blog\u3011\n\n    * \u30103\u2020 All Blog Posts \u3011 \n    * \u301091\u2020 A Week of Symfony \u3011 \n    * \u301092\u2020 Case Studies \u3011 \n    * \u301093\u2020 Cloud \u3011 \n    * \u301094\u2020 Community \u3011 \n    * \u301095\u2020 Conferences \u3011 \n    * \u301096\u2020 Diversity \u3011 \n    * \u301097\u2020 Living on the edge \u3011 \n    * \u301098\u2020 Releases \u3011 \n    * \u301099\u2020 Security Advisories \u3011 \n    * \u3010100\u2020 Symfony Insight \u3011 \n    * \u3010101\u2020 Twig \u3011 \n    * \u3010102\u2020 SensioLabs Blog \u2020sensiolabs.com\u3011 \n  * \u3010103\u2020Services\u2020sensiolabs.com\u3011\n\n    * \u3010103\u2020 SensioLabs services \u2020sensiolabs.com\u3011 \n    * \u301076\u2020 Train developers \u2020sensiolabs.com\u3011 \n    * \u3010104\u2020 Manage your project quality \u2020insight.symfony.com\u3011 \n    * \u301016\u2020 Improve your project performance \u2020www.blackfire.io\u3011 \n    * \u301012\u2020 Host Symfony projects \u3011 \n\n\u301012\u2020Powered by\u3011\n\n\u301012\u2020 \u3011 \n\n### Follow Symfony\n\n\u3010105\u2020 \u2020github.com\u3011 \u3010106\u2020 \u3011 \u3010107\u2020 \u2020twitter.com\u3011 \u3010108\u2020 \u2020mastodon.social\u3011 \u3010109\u2020 \u2020www.linkedin.com\u3011 \u3010110\u2020 \u2020www.facebook.com\u3011 \u3010111\u2020 \u2020www.youtube.com\u3011 \u3010112\u2020 \u2020bsky.app\u3011 \u3010113\u2020 \u2020www.threads.net\u3011 \u301079\u2020 \u2020symfonycasts.com\u3011 \u3010114\u2020 \u2020feeds.feedburner.com\u3011 \n\nSite appearance: Light mode Dark mode Sync with system\n\nCLOSE\n\nSearch Symfony Docs\n\nSearch",
    "title": "https://symfony.com/doc/current/scheduler.html",
    "urls": {
      "0": "https://symfony.com/",
      "1": "https://symfony.com/what-is-symfony",
      "2": "https://symfony.com/community",
      "3": "https://symfony.com/blog/",
      "4": "https://symfony.com/doc/current/contributing/index.html",
      "5": "https://symfony.com/support",
      "6": "https://symfony.com/doc",
      "7": "https://symfony.com/book",
      "8": "https://symfonycasts.com",
      "9": "https://symfony.com/bundles",
      "10": "https://symfony.com/doc/cloud/",
      "11": "https://sensiolabs.com/training?utm_source=symfony&utm_medium=symfony_submenu&utm_campaign=permanent_referral",
      "12": "https://symfony.com/cloud/",
      "13": "https://insight.symfony.com",
      "14": "https://certification.symfony.com",
      "15": "https://sensiolabs.com/?utm_source=symfony&utm_medium=symfony_submenu&utm_campaign=permanent_referral",
      "16": "https://www.blackfire.io/?utm_source=symfony&utm_medium=symfonycom_footer&utm_campaign=profiler",
      "17": "https://symfony.com/download",
      "18": "https://sensiolabs.com/?utm_source=symfony&utm_medium=symfony_sponsoredby&utm_campaign=permanent_referral",
      "19": "https://github.com/symfony/symfony-docs/edit/7.3/scheduler.rst",
      "20": "https://symfonycasts.com/screencast/mailtrap/bonus-symfony-scheduler",
      "21": "https://symfony.com/doc/current/setup.html#symfony-flex",
      "22": "https://symfony.com/doc/current/components/messenger.html",
      "23": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Messenger/SchedulerTransport.php",
      "24": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/RecurringMessage.php",
      "25": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/ScheduleProviderInterface.php",
      "26": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/ScheduleProviderInterface.php#:~:text=function%20getSchedule",
      "27": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Attribute/AsSchedule.php",
      "28": "https://en.wikipedia.org/wiki/Memoization",
      "29": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/CronExpressionTrigger.php",
      "30": "https://en.wikipedia.org/wiki/Cron",
      "31": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/CallbackTrigger.php",
      "32": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/ExcludeTimeTrigger.php",
      "33": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/JitterTrigger.php",
      "34": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/PeriodicalTrigger.php",
      "35": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/AbstractDecoratedTrigger.php#:~:text=function%20inner",
      "36": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/AbstractDecoratedTrigger.php#:~:text=function%20decorators",
      "37": "https://crontab.guru/",
      "38": "https://symfony.com/doc/current/scheduler.html#scheduler-attributes-cron-task",
      "39": "https://www.php.net/manual/en/datetime.formats.php#datetime.formats.relative",
      "40": "https://symfony.com/doc/current/scheduler.html#scheduler-attributes-periodic-task",
      "41": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/TriggerInterface.php",
      "42": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Trigger/CallbackMessageProvider.php",
      "43": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Attribute/AsPeriodicTask.php",
      "44": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Attribute/AsCronTask.php",
      "45": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Schedule.php#:~:text=function%20add",
      "46": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Schedule.php#:~:text=function%20remove",
      "47": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Schedule.php#:~:text=function%20clear",
      "48": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Schedule.php",
      "49": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Schedule.php#:~:text=function%20removeById",
      "50": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Event/PreRunEvent.php#:~:text=function%20shouldCancel",
      "51": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Event/PreRunEvent.php",
      "52": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Event/PostRunEvent.php",
      "53": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Event/FailureEvent.php",
      "54": "https://symfony.com/doc/current/messenger.html#deploying-to-production",
      "55": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Scheduler.php",
      "56": "https://symfony.com/doc/current/components/cache.html",
      "57": "https://symfony.com/doc/current/components/lock.html",
      "58": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Messenger/Message/RedispatchMessage.php",
      "59": "https://github.com/symfony/symfony/blob/7.3/src/Symfony/Component/Scheduler/Messenger/ScheduledStamp.php",
      "60": "https://creativecommons.org/licenses/by-sa/3.0/",
      "61": "https://symfony.com/backers",
      "62": "https://les-tilleuls.coop/",
      "63": "https://www.blackfire.io/profiler?utm_source=symfony&utm_medium=ad_white_logo&utm_campaign=profiler",
      "64": "https://sensiolabs.com/services?utm_source=symfony&utm_medium=ad_visual&utm_campaign=permanent_referral",
      "65": "https://symfony.com/contributors",
      "66": "https://symfony.com/trademark",
      "67": "https://symfony.com/at-a-glance",
      "68": "https://symfony.com/packages",
      "69": "https://symfony.com/releases",
      "70": "https://symfony.com/doc/current/contributing/code/security.html",
      "71": "https://symfony.com/logo",
      "72": "https://symfony.com/license",
      "73": "https://symfony.com/legacy",
      "74": "https://symfony.com/doc/current/reference/index.html",
      "75": "https://symfony.com/doc/current/best_practices.html",
      "76": "https://sensiolabs.com/training?utm_source=symfony&utm_medium=symfony_footer&utm_campaign=permanent_referral",
      "77": "https://university.sensiolabs.com/e-learning-platform?utm_source=symfony&utm_medium=symfony_footer&utm_campaign=permanent_referral",
      "78": "https://certification.symfony.com/",
      "79": "https://symfonycasts.com/",
      "80": "https://symfonycasts.com/tracks/symfony",
      "81": "https://symfonycasts.com/tracks/php",
      "82": "https://symfonycasts.com/tracks/javascript",
      "83": "https://symfonycasts.com/tracks/drupal",
      "84": "https://symfonycasts.com/tracks/rest",
      "85": "https://connect.symfony.com/",
      "86": "https://symfony.com/events/",
      "87": "https://symfony.com/projects",
      "88": "https://symfony.com/jobs",
      "89": "https://symfony.com/doc/current/contributing/code_of_conduct/code_of_conduct.html",
      "90": "https://symfony.com/stats/downloads",
      "91": "https://symfony.com/blog/category/a-week-of-symfony",
      "92": "https://symfony.com/blog/category/case-studies",
      "93": "https://symfony.com/blog/category/cloud",
      "94": "https://symfony.com/blog/category/community",
      "95": "https://symfony.com/blog/category/conferences",
      "96": "https://symfony.com/blog/category/diversity",
      "97": "https://symfony.com/blog/category/living-on-the-edge",
      "98": "https://symfony.com/blog/category/releases",
      "99": "https://symfony.com/blog/category/security-advisories",
      "100": "https://symfony.com/blog/category/symfony-insight",
      "101": "https://symfony.com/blog/category/twig",
      "102": "https://sensiolabs.com/blog?utm_source=symfony&utm_medium=symfony_footer&utm_campaign=permanent_referral",
      "103": "https://sensiolabs.com/?utm_source=symfony&utm_medium=symfony_footer&utm_campaign=permanent_referral",
      "104": "https://insight.symfony.com/",
      "105": "https://github.com/symfony",
      "106": "https://symfony.com/slack",
      "107": "https://twitter.com/symfony",
      "108": "https://mastodon.social/@symfony",
      "109": "https://www.linkedin.com/company/symfony-sas/",
      "110": "https://www.facebook.com/SymfonyFramework",
      "111": "https://www.youtube.com/symfonytv",
      "112": "https://bsky.app/profile/symfony.com",
      "113": "https://www.threads.net/@symfony",
      "114": "https://feeds.feedburner.com/symfony/blog"
    },
    "snippets": null,
    "error_message": null
  },
  "cursor": -1,
  "id": 0
}